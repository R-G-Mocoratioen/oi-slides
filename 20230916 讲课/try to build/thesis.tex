\documentclass{noithesis}

\usepackage{graphicx}
\usepackage{float}

\newtheorem{example}{例}
\newtheorem{property}{性质}

\newenvironment{solution}{{\noindent\it 解法}\quad}{\hfill $\square$\par}



\begin{document}

\title {题目思路要点}

\author {lsy}

\maketitle

%\tableofcontents{}

\section{CF1290E}

笛卡尔树上一个子树对应一个区间 $[l,r]$，考虑维护新序列上（不是原序列！）每个原序列上对应值管辖到的位置，设位置为 $[l,r]$。那就是要求 $\sum r-l+1$。看见“和的和”就应该想到把和拆开。这样，$l,r$ 是独立的，且显然有对称性，不妨设求 $r$，现在插入了 $n$：

\begin{itemize}
\item $n$ 左边的数，$r$ 对 $pos_n$ 取 min。
\item $n$ 右边的数，$r$ 加了一。
\end{itemize}

注意一个位置没被用到的时候，加一操作是不该影响它的。但是线段树上，这也好解决。

\section{UOJ515}

从后往前对下标扫描线（记住这个思想）。维护一个序列，下标是时间，表示每个时刻该位置的后缀最小值。

如果一个位置 $i$ 在 $[l,r]$ 时间等于 $v$，对序列的影响就是 $i+1\to i$ 时，$a_{l\sim r}$ 对 $v$ 取 min。

后缀最小值个数就是被取 min 的次数，segtree beats 维护即可。

\section{CF1824D}

如果我们有一个用区间加维护出 $g(*,r)$ 的做法，套上历史和就能得到原题做法。

假设 $pre_i$ 是最后一个和 $i$ 相同的位置。把所有最后一次出现的位置画出来，分类讨论即可得到具体哪些区间加了。

\section{P8868}

根据 CF526F 的经验，区间最大值是很容易维护出来的，所以就是要支持

\begin{itemize}
\item 给 $a$ 数组区间加
\item 给 $b$ 数组区间加
\item 求 $a\times b$ 的区间历史和
\end{itemize}

这也可以矩阵维护。看一下矩阵哪些位置永远是 0，可以卡常数。

\section{P5445}

这个题可以看成是二维平面上矩形加，求单点历史版本和。

直接用矩阵做当然可以，这里介绍一下用时间求历史版本和的做法。

设 $A$ 是我们进行操作的数组，$B$ 是历史版本和数组，$t$ 是当前时间。令 $C=B-At$，维护 $A,C$ 就能维护出 $B$ 了，而 $A,C$ 都只需要区间加。放到这个题上用 CDQ 分治即可。

\section{P8987}

本题比较 Educational，它给我们指出一种考虑每个元素“是否被某种意义上操作过”而分开维护的思想。

“被操作过一次”之后，可能元素之间就会存在单调性或其它性质了。

注意到本题中，如果 $a_i$ 没有初值，则它一定一直都是单调不降的。但如果会出现 $i$ 被 min 操作影响了，$i+1$ 又没被影响的情况，肯定会破坏“单调不降”的性质。不过反证一下就知道这样的状况不会出现。

所以如果我们每次操作能快速知道哪些 $a_i$ 被影响了，就用两个数据结构分别维护被影响的和没被影响的即可。

怎么知道 $a_i$ 第一次被影响在何时呢？若操作 $j$ 是 1 操作，之前有 $b_j$ 次操作 2，$a_i+ib_j\ge v_j$ 就说明 $a_i$ 被影响了。相当于，$i$ 在 $\le j$ 的时刻是否被影响，就是 $\min_{v_j-ib_j}\le a_i$ 是否成立。可持久化李超线段树记下来所有版本的 $\min_{v_j-ib_j}$，二分时间即可。

\section{CF1140F}

注意一个连通块会被变成完全二分图。

\section{QOJ5098}

本题有两种做法。

\subsection{线段树分治}

考虑不带修。设 $L_i$ 表示 $i$ 之前最后一个和 $i$ 相同的。则答案中以 $i$ 为右端点的区间，左端点至少是 $\max_{1\le j\le i}L_j+1$。设 $l_i$ 是 $L$ 前缀最大值，则 $l$ 单调，所以可以二分分界点。

带上修了，把修改变成加入新限制 $(i,L_i)$，那 $l$ 也很容易维护了。

\subsection{带 log pushup 线段树}

考虑直接支持修改 $L$，不维护 $l$ 了。

设函数 $f(l',p)$ 表示在线段树上 $p$ 结点之前加一个 $l'$，这时答案是多少。这个函数就是“带 log pushup 线段树”可以胜任的。

\end{document}
